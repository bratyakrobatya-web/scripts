# -*- coding: utf-8 -*-
"""
Скрипт для сопоставления external_id между файлами ВНУТРЕННИЙ и БИЛЛИНГ
Сопоставление по: ФИО (name), Дата попадания на стейт (lead_date), Город (city)
"""

# ============================================
# УСТАНОВКА БИБЛИОТЕК (выполнить в отдельной ячейке)
# ============================================
# !pip install pandas openpyxl fuzzywuzzy python-Levenshtein

# ============================================
# ИМПОРТ БИБЛИОТЕК
# ============================================
import pandas as pd
import numpy as np
from datetime import datetime
import re
from fuzzywuzzy import fuzz
from google.colab import files
import os

# ============================================
# ЗАГРУЗКА ФАЙЛОВ
# ============================================
print("Загрузите ВСЕ файлы (ВНУТРЕННИЙ, БИЛЛИНГ и ЛК ЯЕДА):")
uploaded_files = files.upload()

df_internal = None
df_billing = None
df_lk_yeda = None
internal_filename = None
billing_filename = None
lk_yeda_filename = None

for filename in uploaded_files.keys():
    print(f"\nОбрабатываем файл: {filename}")
    
    if "ООО Хэдхантер Биллинг" in filename or "Биллинг" in filename:
        print(f"  -> Определен как БИЛЛИНГ")
        billing_filename = filename
        # Читаем файл, пропуская первую строку (содержит "ООО «Хэдхантер»")
        df_billing = pd.read_excel(filename, skiprows=1)
        print(f"  -> Загружено {len(df_billing)} строк")
        print(f"  -> Колонки: {list(df_billing.columns)}")
        
    elif "Отчет-по-откликам-по-проектам-работодателя" in filename:
        print(f"  -> Определен как ВНУТРЕННИЙ")
        internal_filename = filename
        # Первая строка - заголовки
        df_internal = pd.read_excel(filename)
        print(f"  -> Загружено {len(df_internal)} строк")
        print(f"  -> Колонки: {list(df_internal.columns)}")
    
    elif "Leads_" in filename:
        print(f"  -> Определен как ЛК ЯЕДА")
        lk_yeda_filename = filename
        # CSV файл
        df_lk_yeda = pd.read_csv(filename)
        print(f"  -> Загружено {len(df_lk_yeda)} строк")
        print(f"  -> Колонки: {list(df_lk_yeda.columns)}")
    else:
        print(f"  -> ВНИМАНИЕ: Не удалось определить тип файла!")
        print(f"     Ожидается 'ООО Хэдхантер Биллинг', 'Отчет-по-откликам-по-проектам-работодателя' или 'Leads_' в названии")

if df_internal is None:
    raise ValueError("Файл ВНУТРЕННИЙ не найден! Убедитесь, что в названии есть 'Отчет-по-откликам-по-проектам-работодателя'")
if df_billing is None:
    raise ValueError("Файл БИЛЛИНГ не найден! Убедитесь, что в названии есть 'ООО Хэдхантер Биллинг'")
if df_lk_yeda is None:
    print("\n⚠️ ВНИМАНИЕ: Файл ЛК ЯЕДА не найден! Дополнительная проверка по телефону будет пропущена.")
else:
    print(f"\n✅ Файл ЛК ЯЕДА загружен для дополнительной проверки")

# ============================================
# НАСТРОЙКА НАЗВАНИЙ КОЛОНОК
# ============================================
# Для файла ВНУТРЕННИЙ:
COL_INTERNAL_FIO = 'ФИО'
COL_INTERNAL_DATE = 'Дата попадания на стейт'
COL_INTERNAL_CITY = 'Проживание'
COL_INTERNAL_PHONE = 'Телефон'

# Для файла БИЛЛИНГ:
COL_BILLING_FIO = 'name'
COL_BILLING_DATE = 'lead_date'
COL_BILLING_CITY = 'city'
COL_BILLING_EXTERNAL_ID = 'external_id'
COL_BILLING_PAYMENT = 'payment'
COL_BILLING_N_ORDERS = 'n_orders_20_days'
COL_BILLING_FIRST_ORDER_DATE = 'first_order_date'

# Для файла ЛК ЯЕДА:
COL_LK_EXTERNAL_ID = 'external_id'
COL_LK_DATE = 'lead_created_at'
COL_LK_FIRST_NAME = 'first_name'
COL_LK_LAST_NAME = 'last_name'
COL_LK_PHONE = 'phone'

print("\n" + "="*50)
print("ПРОВЕРКА КОЛОНОК")
print("="*50)

# Проверка наличия колонок
errors = []
if COL_INTERNAL_FIO not in df_internal.columns:
    errors.append(f"Колонка '{COL_INTERNAL_FIO}' не найдена в файле ВНУТРЕННИЙ")
if COL_INTERNAL_DATE not in df_internal.columns:
    errors.append(f"Колонка '{COL_INTERNAL_DATE}' не найдена в файле ВНУТРЕННИЙ")
if COL_INTERNAL_CITY not in df_internal.columns:
    errors.append(f"Колонка '{COL_INTERNAL_CITY}' не найдена в файле ВНУТРЕННИЙ")
if COL_INTERNAL_PHONE not in df_internal.columns:
    errors.append(f"Колонка '{COL_INTERNAL_PHONE}' не найдена в файле ВНУТРЕННИЙ")

if COL_BILLING_FIO not in df_billing.columns:
    errors.append(f"Колонка '{COL_BILLING_FIO}' не найдена в файле БИЛЛИНГ")
if COL_BILLING_DATE not in df_billing.columns:
    errors.append(f"Колонка '{COL_BILLING_DATE}' не найдена в файле БИЛЛИНГ")
if COL_BILLING_CITY not in df_billing.columns:
    errors.append(f"Колонка '{COL_BILLING_CITY}' не найдена в файле БИЛЛИНГ")
if COL_BILLING_EXTERNAL_ID not in df_billing.columns:
    errors.append(f"Колонка '{COL_BILLING_EXTERNAL_ID}' не найдена в файле БИЛЛИНГ")
if COL_BILLING_PAYMENT not in df_billing.columns:
    errors.append(f"Колонка '{COL_BILLING_PAYMENT}' не найдена в файле БИЛЛИНГ")
if COL_BILLING_N_ORDERS not in df_billing.columns:
    errors.append(f"Колонка '{COL_BILLING_N_ORDERS}' не найдена в файле БИЛЛИНГ")
if COL_BILLING_FIRST_ORDER_DATE not in df_billing.columns:
    errors.append(f"Колонка '{COL_BILLING_FIRST_ORDER_DATE}' не найдена в файле БИЛЛИНГ")

# Проверка ЛК ЯЕДА если загружен
if df_lk_yeda is not None:
    if COL_LK_EXTERNAL_ID not in df_lk_yeda.columns:
        errors.append(f"Колонка '{COL_LK_EXTERNAL_ID}' не найдена в файле ЛК ЯЕДА")
    if COL_LK_DATE not in df_lk_yeda.columns:
        errors.append(f"Колонка '{COL_LK_DATE}' не найдена в файле ЛК ЯЕДА")
    if COL_LK_FIRST_NAME not in df_lk_yeda.columns:
        errors.append(f"Колонка '{COL_LK_FIRST_NAME}' не найдена в файле ЛК ЯЕДА")
    if COL_LK_LAST_NAME not in df_lk_yeda.columns:
        errors.append(f"Колонка '{COL_LK_LAST_NAME}' не найдена в файле ЛК ЯЕДА")
    if COL_LK_PHONE not in df_lk_yeda.columns:
        errors.append(f"Колонка '{COL_LK_PHONE}' не найдена в файле ЛК ЯЕДА")

if errors:
    print("❌ ОШИБКИ:")
    for err in errors:
        print(f"  - {err}")
    raise ValueError("Проверьте структуру файлов")
else:
    print("✅ Все необходимые колонки найдены!")

print(f"\nИспользуются колонки:")
print(f"  ВНУТРЕННИЙ: {COL_INTERNAL_FIO}, {COL_INTERNAL_DATE}, {COL_INTERNAL_CITY}, {COL_INTERNAL_PHONE}")
print(f"  БИЛЛИНГ: {COL_BILLING_FIO}, {COL_BILLING_DATE}, {COL_BILLING_CITY}, {COL_BILLING_EXTERNAL_ID}")
print(f"  Дополнительно из БИЛЛИНГ: {COL_BILLING_PAYMENT}, {COL_BILLING_N_ORDERS}, {COL_BILLING_FIRST_ORDER_DATE}")
if df_lk_yeda is not None:
    print(f"  ЛК ЯЕДА: {COL_LK_EXTERNAL_ID}, {COL_LK_DATE}, {COL_LK_FIRST_NAME}, {COL_LK_LAST_NAME}, {COL_LK_PHONE}")

# ============================================
# ФУНКЦИИ ДЛЯ НОРМАЛИЗАЦИИ ДАННЫХ
# ============================================

def normalize_fio(fio):
    """Нормализация ФИО: убираем лишние пробелы, приводим к нижнему регистру"""
    if pd.isna(fio):
        return ""
    fio = str(fio).strip().lower()
    # Убираем множественные пробелы
    fio = re.sub(r'\s+', ' ', fio)
    return fio

def get_fio_parts(fio):
    """Разбиваем ФИО на части и сортируем для сравнения"""
    if not fio:
        return set(), []
    parts = fio.split()
    return set(parts), sorted(parts)

def normalize_city(city):
    """Нормализация города: убираем лишние пробелы, приводим к нижнему регистру"""
    if pd.isna(city):
        return ""
    city = str(city).strip().lower()
    # Убираем скобки и содержимое в них (например, "Московская область")
    city = re.sub(r'\s*\([^)]*\)', '', city)
    # Убираем "г.", "город", "пос.", "п.", "с." в начале
    city = re.sub(r'^(г\.|город|пос\.|п\.|с\.|село|поселок)\s*', '', city)
    # Убираем "область", "край", "республика" и т.д. в конце
    city = re.sub(r'\s+(область|край|республика|округ|район)$', '', city)
    city = city.strip()
    return city

def extract_city_root(city):
    """Извлекаем корень города для более гибкого сравнения"""
    if not city:
        return ""
    # Берем первое слово (обычно это название города)
    parts = city.split()
    if parts:
        root = parts[0]
        # Убираем окончания (-ский, -ская, -ское, -ий, -ая, -ое)
        root = re.sub(r'(ский|ская|ское|ий|ая|ое|ый)$', '', root)
        return root
    return city

def normalize_date(date_val):
    """Нормализация даты: приводим к формату YYYY-MM-DD"""
    if pd.isna(date_val):
        return None
    
    # Если уже datetime
    if isinstance(date_val, (datetime, pd.Timestamp)):
        return date_val.strftime('%Y-%m-%d')
    
    # Если строка
    date_str = str(date_val).strip()
    
    # Пробуем разные форматы
    formats = [
        '%d-%m-%Y %H:%M:%S',
        '%d.%m.%Y %H:%M:%S',
        '%Y-%m-%d %H:%M:%S',
        '%d-%m-%Y',
        '%d.%m.%Y',
        '%Y-%m-%d',
    ]
    
    for fmt in formats:
        try:
            dt = datetime.strptime(date_str.split()[0] if ' ' in date_str else date_str, fmt.split()[0])
            return dt.strftime('%Y-%m-%d')
        except:
            continue
    
    # Если не удалось распарсить, пробуем pandas
    try:
        return pd.to_datetime(date_val).strftime('%Y-%m-%d')
    except:
        return str(date_val)

def compare_fio(fio1, fio2, threshold=85):
    """Сравнение ФИО с учетом возможных опечаток"""
    if not fio1 or not fio2:
        return False
    
    # Точное совпадение
    if fio1 == fio2:
        return True
    
    # Fuzzy matching
    ratio = fuzz.ratio(fio1, fio2)
    if ratio >= threshold:
        return True
    
    # Сравнение по отдельным словам (фамилия, имя, отчество)
    words1 = set(fio1.split())
    words2 = set(fio2.split())
    
    # Если совпадают минимум 2 слова из 3
    common_words = words1.intersection(words2)
    if len(common_words) >= 2:
        return True
    
    return False

def compare_city(city1, city2):
    """Сравнение городов"""
    if not city1 or not city2:
        return False
    
    # Точное совпадение
    if city1 == city2:
        return True
    
    # Один город содержит другой
    if city1 in city2 or city2 in city1:
        return True
    
    # Fuzzy matching для городов
    ratio = fuzz.ratio(city1, city2)
    if ratio >= 80:
        return True
    
    return False

def compare_city_flexible(city1, city2):
    """Более гибкое сравнение городов"""
    if not city1 or not city2:
        return False
    
    # Базовое сравнение
    if compare_city(city1, city2):
        return True
    
    # Сравнение корней
    root1 = extract_city_root(city1)
    root2 = extract_city_root(city2)
    
    if root1 and root2:
        if root1 == root2:
            return True
        if root1 in root2 or root2 in root1:
            return True
        if fuzz.ratio(root1, root2) >= 75:
            return True
    
    # Частичное совпадение токенов
    token_ratio = fuzz.token_set_ratio(city1, city2)
    if token_ratio >= 70:
        return True
    
    return False

def normalize_phone(phone):
    """Нормализация телефона: оставляем только цифры"""
    if pd.isna(phone):
        return ""
    phone_str = str(phone)
    # Убираем все кроме цифр
    digits = re.sub(r'\D', '', phone_str)
    # Убираем ведущую 7 или 8 если есть
    if len(digits) >= 11 and digits[0] in ['7', '8']:
        digits = digits[1:]
    return digits

def extract_phone_last_digits(masked_phone):
    """Извлекает последние цифры из маскированного номера типа +7******0057"""
    if pd.isna(masked_phone):
        return ""
    phone_str = str(masked_phone)
    # Убираем все кроме цифр
    digits = re.sub(r'\D', '', phone_str)
    # Берем последние 4 цифры
    if len(digits) >= 4:
        return digits[-4:]
    return digits

def compare_phone_with_mask(full_phone, masked_phone):
    """Сравнивает полный номер с маскированным (последние 4 цифры)"""
    if not full_phone or not masked_phone:
        return False
    
    # Нормализуем полный номер
    full_digits = normalize_phone(full_phone)
    # Извлекаем последние цифры из маскированного
    last_digits = extract_phone_last_digits(masked_phone)
    
    if len(full_digits) >= 4 and len(last_digits) >= 4:
        return full_digits[-4:] == last_digits[-4:]
    
    return False

# ============================================
# НОРМАЛИЗАЦИЯ ДАННЫХ
# ============================================
print("\nНормализация данных...")

# Нормализация ВНУТРЕННИЙ
df_internal['_norm_fio'] = df_internal[COL_INTERNAL_FIO].apply(normalize_fio)
df_internal['_norm_date'] = df_internal[COL_INTERNAL_DATE].apply(normalize_date)
df_internal['_norm_city'] = df_internal[COL_INTERNAL_CITY].apply(normalize_city)

# Нормализация БИЛЛИНГ
df_billing['_norm_fio'] = df_billing[COL_BILLING_FIO].apply(normalize_fio)
df_billing['_norm_date'] = df_billing[COL_BILLING_DATE].apply(normalize_date)
df_billing['_norm_city'] = df_billing[COL_BILLING_CITY].apply(normalize_city)

print("Нормализация завершена!")

# ============================================
# СОПОСТАВЛЕНИЕ (ОПТИМИЗИРОВАННАЯ ВЕРСИЯ)
# ============================================
print("\nСоздаем индексы для быстрого поиска...")

# Создаем словарь для быстрого поиска по ФИО + город
billing_index = {}
for bill_idx, bill_row in df_billing.iterrows():
    key = (bill_row['_norm_fio'], bill_row['_norm_city'])
    if key not in billing_index:
        billing_index[key] = []
    billing_index[key].append({
        'external_id': bill_row[COL_BILLING_EXTERNAL_ID],
        'date': bill_row['_norm_date'],
        'original_fio': bill_row[COL_BILLING_FIO],
        'original_city': bill_row[COL_BILLING_CITY],
        'payment': bill_row[COL_BILLING_PAYMENT],
        'n_orders_20_days': bill_row[COL_BILLING_N_ORDERS],
        'first_order_date': bill_row[COL_BILLING_FIRST_ORDER_DATE],
        'lead_date': bill_row[COL_BILLING_DATE]
    })

# Индекс только по ФИО
billing_by_fio = {}
for bill_idx, bill_row in df_billing.iterrows():
    fio = bill_row['_norm_fio']
    if fio not in billing_by_fio:
        billing_by_fio[fio] = []
    billing_by_fio[fio].append({
        'external_id': bill_row[COL_BILLING_EXTERNAL_ID],
        'date': bill_row['_norm_date'],
        'city': bill_row['_norm_city'],
        'original_fio': bill_row[COL_BILLING_FIO],
        'original_city': bill_row[COL_BILLING_CITY],
        'payment': bill_row[COL_BILLING_PAYMENT],
        'n_orders_20_days': bill_row[COL_BILLING_N_ORDERS],
        'first_order_date': bill_row[COL_BILLING_FIRST_ORDER_DATE],
        'lead_date': bill_row[COL_BILLING_DATE]
    })

# Индекс по отсортированным частям ФИО
billing_by_fio_sorted = {}
for bill_idx, bill_row in df_billing.iterrows():
    fio = bill_row['_norm_fio']
    _, sorted_parts = get_fio_parts(fio)
    key = tuple(sorted_parts)
    if key not in billing_by_fio_sorted:
        billing_by_fio_sorted[key] = []
    billing_by_fio_sorted[key].append({
        'external_id': bill_row[COL_BILLING_EXTERNAL_ID],
        'date': bill_row['_norm_date'],
        'city': bill_row['_norm_city'],
        'original_fio': bill_row[COL_BILLING_FIO],
        'original_city': bill_row[COL_BILLING_CITY],
        'norm_fio': fio,
        'payment': bill_row[COL_BILLING_PAYMENT],
        'n_orders_20_days': bill_row[COL_BILLING_N_ORDERS],
        'first_order_date': bill_row[COL_BILLING_FIRST_ORDER_DATE],
        'lead_date': bill_row[COL_BILLING_DATE]
    })

# Индекс по корню города
billing_by_city_root = {}
for bill_idx, bill_row in df_billing.iterrows():
    city_root = extract_city_root(bill_row['_norm_city'])
    if city_root not in billing_by_city_root:
        billing_by_city_root[city_root] = []
    billing_by_city_root[city_root].append({
        'external_id': bill_row[COL_BILLING_EXTERNAL_ID],
        'date': bill_row['_norm_date'],
        'city': bill_row['_norm_city'],
        'fio': bill_row['_norm_fio'],
        'original_fio': bill_row[COL_BILLING_FIO],
        'original_city': bill_row[COL_BILLING_CITY],
        'payment': bill_row[COL_BILLING_PAYMENT],
        'n_orders_20_days': bill_row[COL_BILLING_N_ORDERS],
        'first_order_date': bill_row[COL_BILLING_FIRST_ORDER_DATE],
        'lead_date': bill_row[COL_BILLING_DATE]
    })

# Полный список записей БИЛЛИНГ для двойной проверки
billing_full_list = []
for bill_idx, bill_row in df_billing.iterrows():
    billing_full_list.append({
        'external_id': bill_row[COL_BILLING_EXTERNAL_ID],
        'date': bill_row['_norm_date'],
        'city': bill_row['_norm_city'],
        'fio': bill_row['_norm_fio'],
        'original_fio': bill_row[COL_BILLING_FIO],
        'original_city': bill_row[COL_BILLING_CITY],
        'payment': bill_row[COL_BILLING_PAYMENT],
        'n_orders_20_days': bill_row[COL_BILLING_N_ORDERS],
        'first_order_date': bill_row[COL_BILLING_FIRST_ORDER_DATE],
        'lead_date': bill_row[COL_BILLING_DATE]
    })

unique_billing_fios = list(billing_by_fio.keys())

print(f"Создано {len(billing_index)} уникальных комбинаций ФИО+Город")
print(f"Уникальных ФИО в БИЛЛИНГ: {len(unique_billing_fios)}")
print(f"Уникальных корней городов: {len(billing_by_city_root)}")

# ============================================
# СОЗДАНИЕ ИНДЕКСА ДЛЯ ЛК ЯЕДА (для дополнительной проверки)
# ============================================
lk_yeda_index = {}
if df_lk_yeda is not None:
    print("\nСоздаем индекс для ЛК ЯЕДА...")
    
    for lk_idx, lk_row in df_lk_yeda.iterrows():
        ext_id = lk_row[COL_LK_EXTERNAL_ID]
        
        # Формируем ФИО из first_name + last_name
        first_name = str(lk_row[COL_LK_FIRST_NAME]) if pd.notna(lk_row[COL_LK_FIRST_NAME]) else ""
        last_name = str(lk_row[COL_LK_LAST_NAME]) if pd.notna(lk_row[COL_LK_LAST_NAME]) else ""
        lk_fio = f"{last_name} {first_name}".strip().lower()
        lk_fio = re.sub(r'\s+', ' ', lk_fio)
        
        # Нормализуем дату
        lk_date = normalize_date(lk_row[COL_LK_DATE])
        
        # Извлекаем последние 4 цифры телефона
        lk_phone_last4 = extract_phone_last_digits(lk_row[COL_LK_PHONE])
        
        lk_yeda_index[ext_id] = {
            'fio': lk_fio,
            'date': lk_date,
            'phone_last4': lk_phone_last4,
            'first_name': first_name.lower(),
            'last_name': last_name.lower()
        }
    
    print(f"Создан индекс ЛК ЯЕДА: {len(lk_yeda_index)} записей")

# Нормализуем телефоны во ВНУТРЕННИЙ файле
print("\nНормализация телефонов...")
df_internal['_norm_phone'] = df_internal[COL_INTERNAL_PHONE].apply(normalize_phone)

print("\nНачинаем сопоставление...")

# Добавляем колонки для результатов
df_internal['external_id'] = None
df_internal['score'] = 0
df_internal['match_details'] = None

# Счетчики
total_matches = 0
stats = {
    'exact_all': 0,
    'exact_fio_city': 0,
    'exact_fio_fuzzy_city': 0,
    'sorted_fio_match': 0,
    'fuzzy_fio_city': 0,
    'fio_only': 0,
    'lk_yeda_match': 0,
    'lk_yeda_fio_date_match': 0,
    'double_check': 0,
    'no_match': 0
}

# Добавляем колонки для результатов
df_internal['external_id'] = None
df_internal['payment'] = None
df_internal['n_orders_20_days'] = None
df_internal['Через сколько заказ'] = None
df_internal['score'] = 0
df_internal['match_details'] = None

def calculate_match_score(internal_fio, internal_city, internal_date, 
                          billing_fio, billing_city, billing_date):
    """Вычисляет score совпадения от 0 до 100"""
    score = 0
    details = []
    
    # ФИО (максимум 50 баллов)
    if internal_fio == billing_fio:
        score += 50
        details.append("ФИО:точное")
    else:
        fio_ratio = fuzz.ratio(internal_fio, billing_fio)
        internal_set, _ = get_fio_parts(internal_fio)
        billing_set, _ = get_fio_parts(billing_fio)
        common_words = len(internal_set.intersection(billing_set))
        
        # Бонус за общие слова
        word_score = common_words * 15  # до 45 за 3 слова
        fuzzy_score = fio_ratio * 0.05  # до 5 за 100% fuzzy
        fio_score = min(45, word_score + fuzzy_score)
        score += fio_score
        details.append(f"ФИО:fuzzy({common_words}слов,{fio_ratio}%)")
    
    # Город (максимум 30 баллов)
    if internal_city == billing_city:
        score += 30
        details.append("Город:точный")
    elif compare_city_flexible(internal_city, billing_city):
        city_ratio = fuzz.ratio(internal_city, billing_city)
        city_score = 15 + (city_ratio * 0.15)  # 15-30 баллов
        score += city_score
        details.append(f"Город:похож({city_ratio}%)")
    else:
        details.append("Город:нет")
    
    # Дата (максимум 20 баллов)
    if internal_date and billing_date and internal_date == billing_date:
        score += 20
        details.append("Дата:точная")
    elif internal_date and billing_date:
        # Проверяем близость дат (±3 дня)
        try:
            d1 = datetime.strptime(internal_date, '%Y-%m-%d')
            d2 = datetime.strptime(billing_date, '%Y-%m-%d')
            diff = abs((d1 - d2).days)
            if diff <= 3:
                date_score = 15 - diff * 3
                score += date_score
                details.append(f"Дата:близко({diff}дн)")
            else:
                details.append("Дата:нет")
        except:
            details.append("Дата:ошибка")
    else:
        details.append("Дата:нет")
    
    return score, " | ".join(details)

def double_check_match(internal_fio, internal_city, internal_date, current_best):
    """Двойная проверка для низких score - полный перебор всех записей БИЛЛИНГ
    ТРЕБУЕТСЯ: точное совпадение даты И точное совпадение города
    """
    best_score = current_best['score'] if current_best else 0
    best_match = current_best
    
    internal_set, internal_sorted = get_fio_parts(internal_fio)
    
    for bill in billing_full_list:
        # ОБЯЗАТЕЛЬНО: точное совпадение даты
        if bill['date'] != internal_date:
            continue
        
        # ОБЯЗАТЕЛЬНО: точное совпадение города (после нормализации)
        if bill['city'] != internal_city:
            continue
        
        billing_set, billing_sorted = get_fio_parts(bill['fio'])
        
        # Проверяем ФИО - должно быть хоть одно общее слово
        if not internal_set.intersection(billing_set):
            continue
        
        score, details = calculate_match_score(
            internal_fio, internal_city, internal_date,
            bill['fio'], bill['city'], bill['date']
        )
        
        if score > best_score:
            best_score = score
            best_match = {
                'external_id': bill['external_id'],
                'score': score,
                'details': f"[DOUBLE_CHECK] {details} | Биллинг: {bill['original_fio']} / {bill['original_city']}",
                'payment': bill['payment'],
                'n_orders_20_days': bill['n_orders_20_days'],
                'first_order_date': bill['first_order_date'],
                'lead_date': bill['lead_date']
            }
    
    return best_match

def calculate_days_to_order(first_order_date, lead_date):
    """Вычисляет количество дней между lead_date и first_order_date"""
    if pd.isna(first_order_date) or pd.isna(lead_date):
        return None
    
    try:
        # Преобразуем в datetime если нужно
        if isinstance(first_order_date, str):
            first_order_date = pd.to_datetime(first_order_date)
        if isinstance(lead_date, str):
            lead_date = pd.to_datetime(lead_date)
        
        if isinstance(first_order_date, (datetime, pd.Timestamp)) and isinstance(lead_date, (datetime, pd.Timestamp)):
            diff = (first_order_date - lead_date).days
            return diff
    except:
        pass
    
    return None

# Основной цикл сопоставления
total_rows = len(df_internal)
for idx, row in df_internal.iterrows():
    if idx % 100 == 0:
        print(f"Обработано {idx}/{total_rows} строк... ({idx*100//total_rows}%)")
    
    internal_fio = row['_norm_fio']
    internal_date = row['_norm_date']
    internal_city = row['_norm_city']
    internal_city_root = extract_city_root(internal_city)
    internal_fio_set, internal_fio_sorted = get_fio_parts(internal_fio)
    
    best_match = None
    
    # СТРАТЕГИЯ 1: Точное совпадение ФИО + Город
    exact_key = (internal_fio, internal_city)
    if exact_key in billing_index:
        candidates = billing_index[exact_key]
        best_cand = None
        best_score = 0
        
        for cand in candidates:
            score, details = calculate_match_score(
                internal_fio, internal_city, internal_date,
                internal_fio, internal_city, cand['date']
            )
            if score > best_score:
                best_score = score
                best_cand = cand
                best_details = details
        
        if best_cand:
            best_match = {
                'external_id': best_cand['external_id'],
                'score': best_score,
                'details': f"[EXACT_ALL] {best_details}",
                'payment': best_cand['payment'],
                'n_orders_20_days': best_cand['n_orders_20_days'],
                'first_order_date': best_cand['first_order_date'],
                'lead_date': best_cand['lead_date']
            }
            stats['exact_all'] += 1
    
    # СТРАТЕГИЯ 2: Точное ФИО + похожий город
    if not best_match and internal_fio in billing_by_fio:
        candidates = billing_by_fio[internal_fio]
        for cand in candidates:
            if compare_city_flexible(internal_city, cand['city']):
                score, details = calculate_match_score(
                    internal_fio, internal_city, internal_date,
                    internal_fio, cand['city'], cand['date']
                )
                if not best_match or score > best_match['score']:
                    best_match = {
                        'external_id': cand['external_id'],
                        'score': score,
                        'details': f"[EXACT_FIO_FUZZY_CITY] {details} | Биллинг: {cand['original_city']}",
                        'payment': cand['payment'],
                        'n_orders_20_days': cand['n_orders_20_days'],
                        'first_order_date': cand['first_order_date'],
                        'lead_date': cand['lead_date']
                    }
        if best_match:
            stats['exact_fio_fuzzy_city'] += 1
    
    # СТРАТЕГИЯ 3: ФИО с другим порядком слов + город
    if not best_match:
        sorted_key = tuple(internal_fio_sorted)
        if sorted_key in billing_by_fio_sorted:
            candidates = billing_by_fio_sorted[sorted_key]
            for cand in candidates:
                if compare_city_flexible(internal_city, cand['city']):
                    score, details = calculate_match_score(
                        internal_fio, internal_city, internal_date,
                        cand['norm_fio'], cand['city'], cand['date']
                    )
                    if not best_match or score > best_match['score']:
                        best_match = {
                            'external_id': cand['external_id'],
                            'score': score,
                            'details': f"[SORTED_FIO] {details} | Биллинг: {cand['original_fio']} / {cand['original_city']}",
                            'payment': cand['payment'],
                            'n_orders_20_days': cand['n_orders_20_days'],
                            'first_order_date': cand['first_order_date'],
                            'lead_date': cand['lead_date']
                        }
            if best_match:
                stats['sorted_fio_match'] += 1
    
    # СТРАТЕГИЯ 4: Fuzzy ФИО + город (по корню города)
    if not best_match and internal_city_root in billing_by_city_root:
        candidates = billing_by_city_root[internal_city_root]
        for cand in candidates:
            if not compare_city_flexible(internal_city, cand['city']):
                continue
            
            cand_fio_set, _ = get_fio_parts(cand['fio'])
            common = internal_fio_set.intersection(cand_fio_set)
            
            if len(common) >= 2:
                score, details = calculate_match_score(
                    internal_fio, internal_city, internal_date,
                    cand['fio'], cand['city'], cand['date']
                )
                if not best_match or score > best_match['score']:
                    best_match = {
                        'external_id': cand['external_id'],
                        'score': score,
                        'details': f"[FUZZY_FIO_CITY] {details} | Биллинг: {cand['original_fio']} / {cand['original_city']}",
                        'payment': cand['payment'],
                        'n_orders_20_days': cand['n_orders_20_days'],
                        'first_order_date': cand['first_order_date'],
                        'lead_date': cand['lead_date']
                    }
        if best_match:
            stats['fuzzy_fio_city'] += 1
    
    # СТРАТЕГИЯ 5: Только по ФИО (если уникальное)
    if not best_match and internal_fio in billing_by_fio:
        candidates = billing_by_fio[internal_fio]
        if len(candidates) == 1:
            cand = candidates[0]
            score, details = calculate_match_score(
                internal_fio, internal_city, internal_date,
                internal_fio, cand['city'], cand['date']
            )
            best_match = {
                'external_id': cand['external_id'],
                'score': score,
                'details': f"[FIO_ONLY_UNIQUE] {details} | Биллинг: {cand['original_city']}",
                'payment': cand['payment'],
                'n_orders_20_days': cand['n_orders_20_days'],
                'first_order_date': cand['first_order_date'],
                'lead_date': cand['lead_date']
            }
            stats['fio_only'] += 1
    
    # СТРАТЕГИЯ 6: Поиск через ЛК ЯЕДА (по телефону + ФИО + дате)
    # Запускается когда: не найдено совпадение ИЛИ score < 80
    current_score = best_match['score'] if best_match else 0
    if (not best_match or current_score < 80) and df_lk_yeda is not None and len(lk_yeda_index) > 0:
        internal_phone = row['_norm_phone']
        internal_fio_parts = set(internal_fio.split())

        lk_match_found = False

        # Ищем совпадение в ЛК ЯЕДА
        for ext_id, lk_data in lk_yeda_index.items():
            # Проверяем телефон (последние 4 цифры)
            if not internal_phone or len(internal_phone) < 4:
                continue
            if internal_phone[-4:] != lk_data['phone_last4']:
                continue

            # Проверяем дату (lead_created_at)
            if internal_date != lk_data['date']:
                continue

            # Проверяем ФИО (first_name + last_name из ЛК ЯЕДА)
            lk_first_name = lk_data['first_name']
            lk_last_name = lk_data['last_name']

            # Проверяем, что хотя бы имя или фамилия есть в ФИО
            name_match = False
            if lk_first_name and lk_first_name in internal_fio:
                name_match = True
            if lk_last_name and lk_last_name in internal_fio:
                name_match = True

            # Или проверяем по словам
            lk_parts = set([lk_first_name, lk_last_name]) - {''}
            common_parts = internal_fio_parts.intersection(lk_parts)
            if len(common_parts) >= 1:
                name_match = True

            if not name_match:
                continue

            # НАЙДЕНО СОВПАДЕНИЕ В ЛК ЯЕДА!
            # external_id из ЛК ЯЕДА используется в любом случае
            lk_match_found = True

            # Пытаемся найти дополнительные данные в БИЛЛИНГ по этому external_id
            billing_data = None
            for bill in billing_full_list:
                if bill['external_id'] == ext_id:
                    billing_data = bill
                    break

            # Вычисляем score
            score = 100  # Высокий score т.к. совпадение по телефону + дате + ФИО из ЛК ЯЕДА
            details = f"Телефон:совпал(***{internal_phone[-4:]}) | Дата:точная | ФИО:частично(ЛК:{lk_last_name} {lk_first_name})"

            # Формируем результат с external_id из ЛК ЯЕДА
            if billing_data:
                # Если нашли в БИЛЛИНГ - берем оттуда payment, n_orders и т.д.
                best_match = {
                    'external_id': ext_id,
                    'score': score,
                    'details': f"[LK_YEDA_PHONE] {details} | Биллинг: {billing_data['original_fio']} / {billing_data['original_city']}",
                    'payment': billing_data['payment'],
                    'n_orders_20_days': billing_data['n_orders_20_days'],
                    'first_order_date': billing_data['first_order_date'],
                    'lead_date': billing_data['lead_date']
                }
            else:
                # Если НЕ нашли в БИЛЛИНГ - все равно используем external_id из ЛК ЯЕДА
                best_match = {
                    'external_id': ext_id,
                    'score': score,
                    'details': f"[LK_YEDA_PHONE] {details} | ЛК:{lk_data['fio']} (данных в БИЛЛИНГ нет)",
                    'payment': None,
                    'n_orders_20_days': None,
                    'first_order_date': None,
                    'lead_date': lk_data['date']  # Используем дату из ЛК ЯЕДА
                }

            stats['lk_yeda_match'] += 1
            break

        # Если нашли через ЛК ЯЕДА - не делаем DOUBLE_CHECK
        if lk_match_found:
            pass  # best_match уже установлен

    # СТРАТЕГИЯ 7: Поиск через ЛК ЯЕДА (по ФИО + дате БЕЗ телефона)
    # Запускается когда: не найдено совпадение ИЛИ score < 70
    current_score = best_match['score'] if best_match else 0
    if (not best_match or current_score < 70) and df_lk_yeda is not None and len(lk_yeda_index) > 0:
        internal_fio_parts = set(internal_fio.split())

        lk_match_found = False

        # Ищем совпадение в ЛК ЯЕДА БЕЗ проверки телефона
        for ext_id, lk_data in lk_yeda_index.items():
            # Проверяем дату (lead_created_at) - обязательно
            if internal_date != lk_data['date']:
                continue

            # Проверяем ФИО (first_name + last_name из ЛК ЯЕДА)
            lk_first_name = lk_data['first_name']
            lk_last_name = lk_data['last_name']

            # Более строгая проверка ФИО - требуем минимум 2 совпадающих слова
            lk_parts = set([lk_first_name, lk_last_name]) - {''}
            common_parts = internal_fio_parts.intersection(lk_parts)

            # Требуем хотя бы 2 общих слова (фамилия + имя или имя + отчество)
            if len(common_parts) < 2:
                continue

            # НАЙДЕНО СОВПАДЕНИЕ В ЛК ЯЕДА (по ФИО + дате без телефона)!
            # external_id из ЛК ЯЕДА используется в любом случае
            lk_match_found = True

            # Пытаемся найти дополнительные данные в БИЛЛИНГ по этому external_id
            billing_data = None
            for bill in billing_full_list:
                if bill['external_id'] == ext_id:
                    billing_data = bill
                    break

            # Вычисляем score
            score = 95  # Немного ниже чем для телефона, т.к. нет проверки телефона
            details = f"Дата:точная | ФИО:совпало({len(common_parts)}слов:ЛК:{lk_last_name} {lk_first_name})"

            # Формируем результат с external_id из ЛК ЯЕДА
            if billing_data:
                # Если нашли в БИЛЛИНГ - берем оттуда payment, n_orders и т.д.
                best_match = {
                    'external_id': ext_id,
                    'score': score,
                    'details': f"[LK_YEDA_FIO_DATE] {details} | Биллинг: {billing_data['original_fio']} / {billing_data['original_city']}",
                    'payment': billing_data['payment'],
                    'n_orders_20_days': billing_data['n_orders_20_days'],
                    'first_order_date': billing_data['first_order_date'],
                    'lead_date': billing_data['lead_date']
                }
            else:
                # Если НЕ нашли в БИЛЛИНГ - все равно используем external_id из ЛК ЯЕДА
                best_match = {
                    'external_id': ext_id,
                    'score': score,
                    'details': f"[LK_YEDA_FIO_DATE] {details} | ЛК:{lk_data['fio']} (данных в БИЛЛИНГ нет)",
                    'payment': None,
                    'n_orders_20_days': None,
                    'first_order_date': None,
                    'lead_date': lk_data['date']  # Используем дату из ЛК ЯЕДА
                }

            stats['lk_yeda_fio_date_match'] += 1
            break

        # Если нашли через ЛК ЯЕДА - не делаем DOUBLE_CHECK
        if lk_match_found:
            pass  # best_match уже установлен

    # ДВОЙНАЯ ПРОВЕРКА для низких score (< 95)
    # НЕ применяем к результатам из ЛК ЯЕДА (они уже проверены)
    if best_match and best_match['score'] < 95 and '[LK_YEDA_PHONE]' not in best_match['details'] and '[LK_YEDA_FIO_DATE]' not in best_match['details']:
        improved_match = double_check_match(internal_fio, internal_city, internal_date, best_match)
        if improved_match and improved_match['score'] > best_match['score']:
            best_match = improved_match
            stats['double_check'] += 1
    
    # Если вообще ничего не нашли - делаем полный перебор (только с точной датой и городом)
    if not best_match:
        best_match = double_check_match(internal_fio, internal_city, internal_date, None)
        if best_match and best_match['score'] >= 70:  # Минимальный порог для DOUBLE_CHECK = 70
            stats['double_check'] += 1
        else:
            best_match = None
            stats['no_match'] += 1
    
    # ФИНАЛЬНАЯ ВАЛИДАЦИЯ: проверяем score и точность совпадений
    if best_match:
        # НЕ применяем валидацию к результатам из ЛК ЯЕДА (они уже проверены)
        is_lk_yeda_match = '[LK_YEDA_PHONE]' in best_match['details'] or '[LK_YEDA_FIO_DATE]' in best_match['details']

        if not is_lk_yeda_match:
            # Для DOUBLE_CHECK требуем score >= 70 (уже проверено выше, но на всякий случай)
            if '[DOUBLE_CHECK]' in best_match['details'] and best_match['score'] < 70:
                best_match = None
                stats['no_match'] += 1
            # Для score < 95 ТРЕБУЕМ точное совпадение даты И города
            elif best_match['score'] < 95:
                has_exact_date = "Дата:точная" in best_match['details']
                has_exact_city = "Город:точный" in best_match['details']

                if not (has_exact_date and has_exact_city):
                    # Отклоняем совпадение - риск дубликата
                    best_match = None
                    stats['no_match'] += 1
    
    # Записываем результат
    if best_match:
        df_internal.at[idx, 'external_id'] = best_match['external_id']
        df_internal.at[idx, 'payment'] = best_match['payment']
        df_internal.at[idx, 'n_orders_20_days'] = best_match['n_orders_20_days']
        df_internal.at[idx, 'score'] = best_match['score']
        df_internal.at[idx, 'match_details'] = best_match['details']
        
        # Вычисляем "Через сколько заказ"
        days_to_order = calculate_days_to_order(
            best_match['first_order_date'], 
            best_match['lead_date']
        )
        df_internal.at[idx, 'Через сколько заказ'] = days_to_order
        
        total_matches += 1
    else:
        df_internal.at[idx, 'score'] = 0
        df_internal.at[idx, 'match_details'] = "НЕ НАЙДЕНО"

print(f"\n{'='*50}")
print("РЕЗУЛЬТАТЫ СОПОСТАВЛЕНИЯ")
print(f"{'='*50}")
print(f"Всего строк: {total_rows}")
print(f"Найдено совпадений: {total_matches} ({total_matches*100//total_rows}%)")
print(f"\nПо стратегиям:")
print(f"  - Точное ФИО + точный город: {stats['exact_all']}")
print(f"  - Точное ФИО + похожий город: {stats['exact_fio_fuzzy_city']}")
print(f"  - ФИО (другой порядок) + город: {stats['sorted_fio_match']}")
print(f"  - Fuzzy ФИО + город: {stats['fuzzy_fio_city']}")
print(f"  - Только по ФИО (уникальное): {stats['fio_only']}")
print(f"  - Через ЛК ЯЕДА (телефон+дата+ФИО): {stats['lk_yeda_match']}")
print(f"  - Через ЛК ЯЕДА (дата+ФИО без телефона): {stats['lk_yeda_fio_date_match']}")
print(f"  - Улучшено двойной проверкой: {stats['double_check']}")
print(f"Не найдено: {stats['no_match']}")

# Статистика по score
print(f"\nРаспределение по score:")
score_ranges = [
    (95, 100, "Отличное совпадение"),
    (80, 94, "Хорошее совпадение"),
    (60, 79, "Среднее совпадение"),
    (50, 59, "Слабое совпадение"),
    (0, 49, "Не найдено / очень слабое")
]
for low, high, label in score_ranges:
    count = len(df_internal[(df_internal['score'] >= low) & (df_internal['score'] <= high)])
    print(f"  {low}-{high} ({label}): {count}")

# ============================================
# УДАЛЕНИЕ ВРЕМЕННЫХ КОЛОНОК
# ============================================
cols_to_drop = ['_norm_fio', '_norm_date', '_norm_city', '_norm_phone']
# Удаляем только те колонки, которые существуют
cols_to_drop = [col for col in cols_to_drop if col in df_internal.columns]
df_internal = df_internal.drop(columns=cols_to_drop)

# ============================================
# ПРОВЕРКА И УДАЛЕНИЕ ДУБЛЕЙ ПО EXTERNAL_ID
# ============================================
print("\nПроверка на дубликаты external_id...")

# Находим дубли (только среди найденных совпадений)
matched_mask = df_internal['external_id'].notna()
duplicates = df_internal[matched_mask].duplicated(subset=['external_id'], keep=False)
duplicate_ids = df_internal[matched_mask][duplicates]['external_id'].unique()

if len(duplicate_ids) > 0:
    print(f"Найдено {len(duplicate_ids)} external_id с дублями")
    
    removed_count = 0
    for ext_id in duplicate_ids:
        # Находим все строки с этим external_id
        mask = df_internal['external_id'] == ext_id
        indices = df_internal[mask].index.tolist()
        
        if len(indices) > 1:
            # Находим индекс с максимальным score
            scores = df_internal.loc[indices, 'score'].tolist()
            max_score_idx = indices[scores.index(max(scores))]
            
            # Удаляем значения у остальных (оставляем только с максимальным score)
            for idx in indices:
                if idx != max_score_idx:
                    df_internal.at[idx, 'external_id'] = None
                    df_internal.at[idx, 'payment'] = None
                    df_internal.at[idx, 'n_orders_20_days'] = None
                    df_internal.at[idx, 'Через сколько заказ'] = None
                    old_score = df_internal.at[idx, 'score']
                    df_internal.at[idx, 'score'] = 0
                    df_internal.at[idx, 'match_details'] = f"УДАЛЕН ДУБЛЬ (был score={old_score}, оставлен score={max(scores)})"
                    removed_count += 1
                    total_matches -= 1
    
    print(f"Удалено {removed_count} дублирующих записей")
    print(f"Итого совпадений после удаления дублей: {total_matches}")
else:
    print("✅ Дубликатов не найдено!")

# ============================================
# СОРТИРОВКА ПО SCORE (по убыванию - лучшие совпадения вначале)
# ============================================
print("\nСортировка результатов по score...")
df_internal = df_internal.sort_values(by='score', ascending=False).reset_index(drop=True)

# ============================================
# СОХРАНЕНИЕ РЕЗУЛЬТАТА
# ============================================
output_filename = 'ВНУТРЕННИЙ_с_external_id.xlsx'

# Переупорядочиваем колонки: все исходные + новые в конце
original_cols = [col for col in df_internal.columns if col not in ['external_id', 'payment', 'n_orders_20_days', 'Через сколько заказ', 'score', 'match_details']]
new_cols = ['external_id', 'payment', 'n_orders_20_days', 'Через сколько заказ', 'score', 'match_details']
df_internal = df_internal[original_cols + new_cols]

df_internal.to_excel(output_filename, index=False)

print(f"\nРезультат сохранен в файл: {output_filename}")
print(f"Файл содержит все исходные колонки + external_id, payment, n_orders_20_days, Через сколько заказ, score, match_details")
print(f"Сортировка: по убыванию score (лучшие совпадения вначале)")

# Скачивание файла
files.download(output_filename)

# ============================================
# ПРОСМОТР РЕЗУЛЬТАТОВ
# ============================================
print("\n" + "="*50)
print("ПРИМЕРЫ ЛУЧШИХ СОВПАДЕНИЙ (score >= 95):")
print("="*50)

top_matches = df_internal[df_internal['score'] >= 95].head(5)
if len(top_matches) > 0:
    for idx, row in top_matches.iterrows():
        print(f"  {row[COL_INTERNAL_FIO]} | {row[COL_INTERNAL_CITY]}")
        print(f"    -> external_id: {row['external_id']}")
        print(f"    -> score: {row['score']}")
        print(f"    -> {row['match_details']}")
        print()
else:
    print("  Нет совпадений с score >= 95")

print("="*50)
print("ПРИМЕРЫ СРЕДНИХ СОВПАДЕНИЙ (score 60-80):")
print("="*50)

mid_matches = df_internal[(df_internal['score'] >= 60) & (df_internal['score'] <= 80)].head(5)
if len(mid_matches) > 0:
    for idx, row in mid_matches.iterrows():
        print(f"  {row[COL_INTERNAL_FIO]} | {row[COL_INTERNAL_CITY]}")
        print(f"    -> external_id: {row['external_id']}")
        print(f"    -> score: {row['score']}")
        print(f"    -> {row['match_details']}")
        print()
else:
    print("  Нет совпадений в этом диапазоне")

print("="*50)
print("ПРИМЕРЫ НЕ НАЙДЕННЫХ (score = 0):")
print("="*50)

no_matches_df = df_internal[df_internal['score'] == 0].head(10)
if len(no_matches_df) > 0:
    for idx, row in no_matches_df.iterrows():
        print(f"  {row[COL_INTERNAL_FIO]} | {row[COL_INTERNAL_CITY]}")
    print()
else:
    print("  Все записи сопоставлены!")

print("\n" + "="*50)
print("ГОТОВО!")
print("="*50)
print(f"\nФайл '{output_filename}' готов к скачиванию.")
print("Рекомендация: проверьте записи с score < 80 на корректность сопоставления.")
